# Controllers

```elixir
Mix.install([
  {:bonny, git: "https://github.com/coryodaniel/bonny.git", branch: "master", force: true}
])

Application.put_env(:bonny, :group, "example.com")
Application.put_env(:bonny, :operator_name, "livebook-operator")

defmodule V1 do
  use Bonny.API.Version

  @impl true
  def manifest(), do: defaults()
end
```

## Creating your first Controller

Use `mix bonny.gen.controller` to create a controller. You are going to be asked whether you want to create a CRD for this controller or not. It defaults to `yes`, as in most cases you probably want to define a custom resource which you're goint to control with your controller. However, your controller could also act upon events on other resources like `configmaps`, `deployments` or even custom resources defined by other operators. The mix task will then guide you through the creation of controller and if applicable a CRD version (see [versions.livemd](versions.livemd)).

## Controlled Resource

A controller watches for events of a certain resource type and acts upon them. Therefore, when `use`-ing `Bonny.ControllerV2`, you have to to define WHICH resource endpoint to "monitor". You do this through the `for_resource` options.

### Defining Custom Resources

To configure a controller for a custom resource, you pass a `%Bonny.API.CRD{}` struct with the `for_resource` option. This will automatically add a function `crd_manifest/0` to your controller which is used by `mix bonny.gen.manifest` to generate the CRD manifest.

```elixir
defmodule AppleController do
  use Bonny.ControllerV2,
    for_resource: %Bonny.API.CRD{
      group: "example.com",
      scope: :Namespaced,
      names: Bonny.API.CRD.kind_to_names("Apple"),
      versions: [V1]
    }
end

AppleController.crd_manifest()
```

Note that these example throw compiler warnings because we haven't declared the action handlers. Let's ignore them for now.

Instead of defining the full CRD, you can use the `Bonny.API.CRD.build_for_controller!/1` macro. It will make an educated guess for the names using the controller module name and take the group form `config.exs`. You only have to pass the versions (which are handled in a [separate guide](versions.livemd)).

```elixir
defmodule AppleController do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.CRD.build_for_controller!(versions: [V1])
end

AppleController.crd_manifest()
```

### A Controller for other Resources

To configure a controller for let's say a core resource, you pass a `%Bonny.API.ResourceEndpoint{}` struct with the `for_resource` option. Note that **no** `crd_manifest/0` function is generated for this controller.

```elixir
defmodule DeploymentController do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.ResourceEndpoint.new!("apps/v1", "Deployment")
end

function_exported?(DeploymentController, :crd_manifest, 0)
```

Note that the example above uses `Bonny.API.ResourceEndpoint.new!/3` to define the resource endpoint.

```elixir
Bonny.API.ResourceEndpoint.new!("apps/v1", "Deployment")
```

```elixir
Bonny.API.ResourceEndpoint.new!("rbac.authorization.k8s.io/v1", "ClusterRole", :Cluster)
```

## Event Handlers

A controller must implements the `behaviour` defined by `Bonny.ControllerV2`. This means it must implement the following action callbacks to handle the events:

* `add/1` - Called upon the resource's creation.
* `delete/1` - Called upon the resource's deletion.
* `modify/1` - Called upon the resource's modification.
* `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

If you used `mix bonny.gen.controller` to create the controller, `add/1` and `modify/1` are delegated to a function `apply/1`. Feel free to change this default behaviour.

```elixir
defmodule Apple do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.CRD.build_for_controller!(versions: [V1])

  @impl true
  def add(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def modify(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def delete(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def reconcile(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end
end
```

### Return Values for Event Handlers

Your event handlers should return one of the following atoms or tuples:

* `:ok` or `:error`  
  Let Bonny know about success or filure.
* `{:ok, "Custom event message"}` or `{:error, "Custom event message"}`  
  (See section [Kubernetes Events](#kubernetes-events))
* `{:ok, resource_with_status}` or `{:error, resource_with_status}`  
  If you decide to set values inside the status subresource (`.status.*`), you can return the resource. Bonny is gonna apply the status for you.
* `{:ok, "Custom event message", resource_with_status}` or `{:error, "Custom event message", resource_with_status}`  
  The combination of the above.

<!-- livebook:{"break_markdown":true} -->

### Features when creating further resources

#### Owner Reference

If your controller creates other resources for your custom resource (e.g. pods, services,...), it is best practice to reference the owner(s). In kubernetes, you do this by adding an entry to `.metadata.ownerReferences`. In your controller's action callbacks, you can use `add_owner_reference/2` for this:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Orange do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.CRD.build_for_controller!(versions: [V1])

  @impl true
  def add(resource) do
    %{
      "apiVersion" => "v1",
      "kind" => "Pod",
      "metadata" => %{"name" => "nginx", "namespace" => "default"}
      #  ...
    }
    |> add_owner_reference(resource)

    # |> K8s.Client.create()
    # |> then(&(K8s.Client.run(conn(), &1))
    :ok
  end

  @impl true
  def modify(_resource), do: :ok

  @impl true
  def delete(_resource), do: :ok

  @impl true
  def reconcile(_resource), do: :ok
end
```

Let's see the resulting resource:

```elixir
Orange.add(%{
  "apiVersion" => "example.com/v1",
  "kind" => "Orange",
  "metadata" => %{
    "name" => "golden",
    "namespace" => "default",
    "uid" => "e19b6f40-3293-11ed-a261-0242ac120002"
  }
})
```

#### Events

See the section [Kubernetes Events](#kubernetes-events) below.

## Customizing Versions in the resulting CRD

Refer to the [Versions](versions.livemd) user guide if you want to define your own OpenAPIV3 schema, add additional printer columns, etc.

## RBAC Rules

Your controller might need special permissions on the kubernetes cluster. Maybe it needs to be able to read secrets. Or it has to be able to create pods. These permissions need to be reflected in the final manifest generated by `mix bonny.gen.manifest` through RBAC rules.

You can define such rules one by one using the `rbac_rule` macro. These rules have to be defined as a tuple in the form `{apiGroup :: binary(), resources :: list(), verb :: list()}`:

```elixir
defmodule Pear do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.CRD.build_for_controller!(versions: [V1])

  # Additional RBAC Rules
  rbac_rule({"", ["secrets"], ["get", "watch", "list"]})
  rbac_rule({"v1", ["pods"], ["get", "watch", "list"]})

  @impl true
  def add(_resource), do: :ok

  @impl true
  def modify(_resource), do: :ok
  @impl true
  def delete(_resource), do: :ok

  @impl true
  def reconcile(_resource), do: :ok
end

# When generating the manifest, an auto-generated function `rules/0` is called.
Pear.rules()
```

## Skipping Observed Generations

One of the kubernetes operator best practices is observing generations. [This blog post explains it really well.](https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792). It is extremly useful especially when you work with status subresources to not get another `modify` event for updating the status.

Bonny supports skipping observed generations of you set the `skip_observed_generations` option to true (see below). If you do this, `add` and `modify` callbacks are not called if a generation has already been observed before.

Behind the scenes, if you set `skip_observed_generations: true`, Bonny adds the status subresource and a field `.status.observedGeneration` to the stored version in your CRD. At runtime, whenever your action callbacks return `:ok`, Bonny updates the status subresource and sets that field to equal `.metadata.generation`.

```elixir
defmodule Plum do
  require Bonny.API.CRD

  use Bonny.ControllerV2,
    for_resource: Bonny.API.CRD.build_for_controller!(versions: [V1]),
    skip_observed_generations: true

  @impl true
  def add(_resource), do: :ok
  @impl true
  def modify(_resource), do: :ok

  @impl true
  def delete(_resource), do: :ok

  @impl true
  def reconcile(_resource), do: :ok
end

Plum.crd_manifest()
```

### Some important remarks

* When enabling skipping of observed generations, you MUST re-generate the manifest using `mix bonny.gen.manifest`.
* Your `apply/1` (and/or `add/1` and `modify/1`) callbacks are not called if you change the metadata of a resource, e.g. labels or annotations (since only changing the spec increments the generation).
* The `reconcile/1` action is meant to "fix" deviated states. Therefore it is always called, even if the reconciled generation has already been observed.

## Kubernetes Events

Kubernetes events provide a way to report back to the client. A Kubernetes event always references the object to which the event relates. For a controller the regarding object would be the handled resource. The user can then use `kubectl describe` on the custom resource to see the events.

For any `:add`, `:modify` or `:delete` action, Bonny creates events for the handled resource.

* If the handler returns `:ok` or one of the allowed result tuples with `:ok` as first element, an event of type `Normal` is created with a default or the given message.
* If the handler returns `:error` or one of the allowed result tuples with `:error` as first element, an event of type `Warning` is created with a default or the given message.

### Example

Assume the following handler for an `ADDED` event:

<!-- livebook:{"force_markdown":true} -->

```elixir
def add(resource) do
  # do the work
  {:ok, "All good over here."}
end
```

Now we can use `kubectl` to create and describe a resource:

```bash
$ kubectl apply -f orange_named_carl.yaml
orange.example.com/carl created

$ kubectl describe orange carl
Name:         carl
Namespace:    default
...
Events:
  Type     Reason        Age    From             Message
  ----     ------        ----   ----             -------
  Normal  SuccessfulAdd  45s    ExampleOperator  All good over here.

```

<!-- livebook:{"break_markdown":true} -->

### Manual Event Creation

Besides the events described above which are created by Bonny, you can create your own events. This is especially useful when your controller creates further resources. For this purpose, Bonny adds functions `event/5` and `event/6` to your controller. You can call it from within any event handler:

<!-- livebook:{"force_markdown":true} -->

```elixir
@doc """
Creates a kubernetes event.

  * regarding: regarding contains the object this Event is about.
    In most cases it's an Object reporting controller implements,
    e.g. ReplicaSetController implements ReplicaSets and this event
    is emitted because it acts on some changes in a ReplicaSet object.
  * related: the related related is the optional secondary object for
    more complex actions. E.g. when regarding object triggers a creation
    or deletion of related object.
  * event_type: `:Normal` or `:Warning`
  * reason: reason is why the action was taken. It is human-readable.
    This field cannot be empty for new Events and it can have at most
    128 characters.
    e.g "SuccessfulResourceCreation"
  * action: e.g. "Add"
  * message: note is a human-readable description of the status of this operation
"""
event(regarding, related \\ nil, event_type, reason, action, message)
```

Note the second argument called `related`. This is where you would pass the resource that was created or modified within your event handler:

<!-- livebook:{"force_markdown":true} -->

```elixir
def add(resource) do
  pod = K8s.Client.create("v1", "pod", name: "foobar", namespace: resource["metadata"]["namespace"])
  case K8s.Client.run(pod) do
    {:ok, created_pod} ->
      event(resource, created_pod, :Normal, "SuccessfulPodCreation", "The pod \"foobar\" was created successfully")
      :ok
    {:error, _} ->
      {:error, "An error occurred during the creation of pod \"foobar\"."}
  end
end
```
