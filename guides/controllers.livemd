# Controllers

```elixir
Mix.install([{:bonny, path: "/Users/mruoss/src/community/bonny"}])

Application.put_env(:bonny, :group, "example.com")
Application.put_env(:bonny, :operator_name, "livebook-operator")
```

## Event Handlers - Creating a simple Controller

Use `mix bonny.gen.controller KindOfYourResource` to create a controller.

Your controller implements the `behaviour` defined in `Bonny.ControllerV2`. It therefore has to implement the following action callbacks to handle the events:

* `add/1` - Called upon the resource's creation.
* `delete/1` - Called upon the resource's deletion.
* `modify/1` - Called upon the resource's modification.
* `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

If you used `mix bonny.gen.controller` to create the controller, `add/1` and `modify/1` are delegated to a function `apply/1`. Feel free to change this default behaviour.

```elixir
defmodule Apple do
  use Bonny.ControllerV2

  @impl true
  def add(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def modify(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def delete(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end

  @impl true
  def reconcile(resource) do
    # Do your work (e.g. create further resources)
    IO.inspect(resource)
    :ok
  end
end
```

### Return Values for Event Handlers

Your event handlers should return one of the following atoms or tuples:

* `:ok` or `:error`  
  Let Bonny know about success or filure.
* `{:ok, "Custom event message"}` or `{:error, "Custom event message"}`  
  (See section [Kubernetes Events](#kubernetes-events))
* `{:ok, resource_with_status}` or `{:error, resource_with_status}`   
  If you decide to set values inside the status subresource (`.status.*`), you can return the resource. Bonny is gonna apply the status for you.
* `{:ok, "Custom event message", resource_with_status}` or `{:error, "Custom event message", resource_with_status}`  
  The combination of the above.

<!-- livebook:{"break_markdown":true} -->

### Features when creating further resources

#### Owner Reference

If your controller creates other resources for your custom resource (e.g. pods, services,...), it is best practice to reference the owner(s). In kubernetes, you do this by adding an entry to `.metadata.ownerReferences`. In your controller's action callbacks, you can use `add_owner_reference/2` for this:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Orange do
  use Bonny.ControllerV2

  @impl true
  def add(resource) do
    %{
      "apiVersion" => "v1",
      "kind" => "Pod",
      "metadata" => %{"name" => "nginx", "namespace" => "default"}
      #  ...
    }
    |> add_owner_reference(resource)

    # |> K8s.Client.create()
    # |> then(&(K8s.Client.run(conn(), &1))
    :ok
  end

  @impl true
  def modify(resource), do: :ok

  @impl true
  def delete(resource), do: :ok

  @impl true
  def reconcile(resource), do: :ok
end
```

Let's see the resulting resource:

```elixir
Orange.add(%{
  "apiVersion" => "example.com/v1",
  "kind" => "Orange",
  "metadata" => %{
    "name" => "golden",
    "namespace" => "default",
    "uid" => "e19b6f40-3293-11ed-a261-0242ac120002"
  }
})
```

#### Events

See the section [Kubernetes Events](#kubernetes-events) below.

## RBAC Rules

Your controller might need special permissions on the kubernetes cluster. Maybe it needs to be able to read secrets. Or it has to be able to create pods. These permissions need to be reflected in the final manifest generated by `mix bonny.gen.manifest` through RBAC rules.

You can define such rules one by one using the `rbac_rule` macro. These rules have to be defined as a tuple in the form `{apiGroup :: binary(), resources :: list(), verb :: list()}`:

```elixir
defmodule Pear do
  use Bonny.ControllerV2

  # Additional RBAC Rules
  rbac_rule({"", ["secrets"], ["get", "watch", "list"]})
  rbac_rule({"v1", ["pods"], ["get", "watch", "list"]})

  @impl true
  def add(resource), do: :ok

  @impl true
  def modify(resource), do: :ok
  @impl true
  def delete(resource), do: :ok

  @impl true
  def reconcile(resource), do: :ok
end

# When generating the manifest, an auto-generated function `rules/0` is called.
Pear.rules()
```

## Custom Resource Definition (CRD)

The controller creates a default CRD from the information it's got, being the module name and some variables defined in `config.exs`. This CRD is used to generate the manifest when running `mix bonny.gen.manifest`. The default CRD for our `Apple` controller looks as follows:

```elixir
Apple.crd() |> Bonny.CRDV2.to_manifest()
```

As you can see, the CRD contains one single version with the default name of "v1" and a very generic OpenAPIV3Schema which allows the spec to be an arbitrary object. If you would like to add additional printer columns or define a more specific schema and profit from kubernetes' input validation, you can implement `customize_crd/1` in your controller.

<!-- livebook:{"break_markdown":true} -->

A simple case where you would just set `additionalPrinterColumns` on the default version:

```elixir
defmodule Peach do
  use Bonny.ControllerV2

  @impl true
  def add(resource), do: :ok

  @impl true
  def modify(resource), do: :ok
  @impl true
  def delete(resource), do: :ok

  @impl true
  def reconcile(resource), do: :ok

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    additional_printer_columns = [
      %{name: "color", type: "string", jsonPath: ".spec.color"},
      %{
        name: "ripe",
        type: "boolean",
        jsonPath: ".spec.ripe",
        description: "Indicates whether the fruit is ripe or not."
      }
    ]

    Bonny.CRDV2.update_versions(
      crd,
      fn version -> struct!(version, additionalPrinterColumns: additional_printer_columns) end
    )
  end
end

Peach.crd() |> Bonny.CRDV2.to_manifest()
```

A more complex case where you redefine the whole CRD including OpenAPIV3Schema:

```elixir
defmodule DatabaseUser do
  use Bonny.ControllerV2

  @impl true
  def add(resource), do: :ok

  @impl true
  def modify(resource), do: :ok

  @impl true
  def delete(resource), do: :ok

  @impl true
  def reconcile(resource), do: :ok

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    open_api_schema = %{
      openAPIV3Schema: %{
        type: :object,
        properties: %{
          spec: %{
            type: :object,
            properties: %{
              username: %{type: :string},
              max_conn: %{
                type: :integer,
                description: "Maximum of simultaneos connections allowed for this user."
              }
            }
          }
        }
      }
    }

    struct!(
      crd,
      versions: [
        Bonny.CRD.Version.new!(
          name: "v1",
          additionalPrinterColumns: [
            %{name: "username", type: "string", jsonPath: ".spec.username"},
            %{
              name: "connections",
              type: "integer",
              jsonPath: ".spec.max_conn",
              description: "Maximum of simultaneos connections allowed for this user."
            }
          ],
          schema: open_api_schema
        ),
        Bonny.CRD.Version.new!(name: "v1beta1", schema: open_api_schema, storage: false)
      ]
    )
  end
end

DatabaseUser.crd() |> Bonny.CRDV2.to_manifest()
```

## Skipping Observed Generations

One of the kubernetes operator best practices is observing generations. [This blog post explains it really well.](https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792). It is extremly useful especially when you work with status subresources to not get another `modify` event for updating the status.

Bonny supports skipping observed generations of you set the `skip_observed_generations` option to true (see below). If you do this, `add` and `modify` callbacks are not called if a generation has already been observed before.

Behind the scenes, if you set `skip_observed_generations: true`, Bonny adds the status subresource and a field `.status.observedGeneration` to the stored version in your CRD. At runtime, whenever your action callbacks return `:ok`, Bonny updates the status subresource and sets that field to equal `.metadata.generation`.

```elixir
defmodule Plum do
  use Bonny.ControllerV2,
    skip_observed_generations: true

  @impl true
  def add(resource), do: :ok
  @impl true
  def modify(resource), do: :ok

  @impl true
  def delete(resource), do: :ok

  @impl true
  def reconcile(resource), do: :ok
end

Plum.crd() |> Bonny.CRDV2.to_manifest()
```

### Some important remarks

* When enabling skipping of observed generations, you MUST re-generate the manifest using `mix bonny.gen.manifest`.
* Your `apply/1` (and/or `add/1` and `modify/1`) callbacks are not called if you change the metadata of a resource, e.g. labels or annotations (since only changing the spec increments the generation).
* The `reconcile/1` action is meant to "fix" deviated states. Therefore it is always called, even if the reconciled generation has already been observed.

## Kubernetes Events

Kubernetes events provide a way to report back to the client. A Kubernetes event always references the object to which the event relates. For a controller the regarding object would be the handled resource. The user can then use `kubectl describe` on the custom resource to see the events.

For any `:add`, `:modify` or `:delete` action, Bonny creates events for the handled resource.

* If the handler returns `:ok` or one of the allowed result tuples with `:ok` as first element, an event of type `Normal` is created with a default or the given message.
* If the handler returns `:error` or one of the allowed result tuples with `:error` as first element, an event of type `Warning` is created with a default or the given message.

### Example

Assume the following handler for an `ADDED` event:

<!-- livebook:{"force_markdown":true} -->

```elixir
def add(resource) do
  # do the work
  {:ok, "All good over here."}
end
```

Now we can use `kubectl` to create and describe a resource:

```bash
$ kubectl apply -f orange_named_carl.yaml
orange.example.com/carl created

$ kubectl describe orange carl
Name:         carl
Namespace:    default
...
Events:
  Type     Reason        Age    From             Message
  ----     ------        ----   ----             -------
  Normal  SuccessfulAdd  45s    ExampleOperator  All good over here.
 
```

<!-- livebook:{"break_markdown":true} -->

### Manual Event Creation

Besides the events described above which are created by Bonny, you can create your own events. This is especially useful when your controller creates further resources. For this purpose, Bonny adds functions `event/5` and `event/6` to your controller. You can call it from within any event handler:

<!-- livebook:{"force_markdown":true} -->

```elixir
@doc """
Creates a kubernetes event.

  * regarding: regarding contains the object this Event is about. 
    In most cases it's an Object reporting controller implements, 
    e.g. ReplicaSetController implements ReplicaSets and this event 
    is emitted because it acts on some changes in a ReplicaSet object.
  * related: the related related is the optional secondary object for 
    more complex actions. E.g. when regarding object triggers a creation 
    or deletion of related object.
  * event_type: `:Normal` or `:Warning`
  * reason: reason is why the action was taken. It is human-readable. 
    This field cannot be empty for new Events and it can have at most 
    128 characters.
    e.g "SuccessfulResourceCreation" 
  * action: e.g. "Add"
  * message: note is a human-readable description of the status of this operation
"""
event(regarding, related \\ nil, event_type, reason, action, message)
```

Note the second argument called `related`. This is where you would pass the resource that was created or modified within your event handler:

<!-- livebook:{"force_markdown":true} -->

```elixir
def add(resource) do
  pod = K8s.Client.create("v1", "pod", name: "foobar", namespace: resource["metadata"]["namespace"])
  case K8s.Client.run(pod) do
    {:ok, created_pod} ->
      event(resource, created_pod, :Normal, "SuccessfulPodCreation", "The pod \"foobar\" was created successfully")
      :ok
    {:error, _} -> 
      {:error, "An error occurred during the creation of pod \"foobar\"."}
  end
end
```
